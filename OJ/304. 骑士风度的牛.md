# 304. 骑士风度的牛

#### 题目描述

 农民约翰有很多牛，他想交易其中一头被Don称为骑士的牛。这头牛有一个独一无二的超能力，在农场里像骑士一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 x,y 的坐标图来表示。

 这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了骑士的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定骑士要想吃到草，至少需要跳多少次。骑士的位置用 K来标记，障碍的位置用 ∗ 来标记，草的位置用 H 来标记。

------

#### 输入

 第一行输入两个数，表示农场的列数 (≤150) 和行数 (≤150)。

 接下来输入地图。

#### 输出

 一个数，表示跳跃的最小次数。

------

#### 样例输入

```c++
10 11
..........
....*.....
..........
...*.*....
.......*..
..*..*...H
*.........
...*...*..
.K........
...*.....*
..*....*..
```

#### 样例输出

```c++
5
```

```c++
#include<iostream>
#include<queue>
using namespace std;

struct Node{
    int x, y, val;
};

char str[200][200];
int n, m;

int dir[8][2] = {
    1, 2, 1, -2, 2, 1, 2, -1,
    -1, 2, -1, -2, -2, 1, -2, -1
};

int main(){
    cin >> m >> n;
    queue<Node> q;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            cin >> str[i][j];
            if(str[i][j] == 'K'){
                q.push({i, j, 0});
                str[i][j] = '*';
            }
        }
    }
    while(!q.empty()){
        Node temp = q.front();
        q.pop();
        for(int i = 0; i < 8; i++){
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if(x < 1 || y < 1 || x > n || y > m || str[x][y] == '*') 
                continue;
            if(str[x][y] == 'H'){
                cout << temp.val + 1;
                return 0;
            }
                q.push({x, y, temp.val + 1});
                str[x][y] = '*';
        }
    }
    return 0;
}
```

